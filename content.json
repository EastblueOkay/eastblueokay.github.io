{"pages":[],"posts":[{"title":"CSS预处理器中使用Webpack alias配置","text":"在使用 webpack 构建项目时，经常会使用到 resolve.alias 的功能。它可以用来创建 import 或 require 的别名，使得模块引入变得更简单。123alias: { '@': 'src/components'} 现在，可以替换替换原有的导入路径方式：1234// beforeimport component from \"src/components/component\"// afterimport component from \"@/component\" 在CSS预处理器的@import中使用alias@import存在于 css 中，而 css 是由 css-loader 来进行处理的，所以在处理过程中并不能使用 webpack loader 的 alias 配置。下面的引入将不会生效：1@import \"@/reset.css\" 使用 ~ 标识符想要在 css 中使用 alias，可以采用如下解决方案：1@import \"~@/reset.css\" ~的作用是告诉 webpack，当前 import 的路径是使用 alias 配置进行导入。可以点击这里查看该css-loader Issues详情","link":"/2018/04/23/CSS预处理器中使用Webpack-alias配置/"},{"title":"JavaScript中的 var、let、const","text":"1、变量提升（hoisting）12console.log(a) // undefinedvar a = 1 上述代码会输出 undefined。是由于var声明的变量会将声明提升到作用域的顶部（实际上let和const都会存在变量提升），也就等价于：123var aconsole.log(a)a = 1 这就是所谓的变量提升。不仅仅变量会被提升，函数也会被提升：123console.log(a) // function a() {}var a = 1function a() {} 且函数提升的优先级始终要大于变量。 2、临时性死区在let和const关键字之前，JavaScript没有块级作用域，只有函数作用域。例如在for循环中使用var声明的变量i，在其之外也可以访问。1234for(var i = 0; i&lt;10; i++){ console.log(i);}console.log(i) // 10 使用let和const声明的关键字拥有块级作用域。若将上述循环变量使用let声明，则在循环块外就无法访问了。那么这就产生了另一个问题：1234for(var i = 0; i&lt;10; i++){ console.log(a) // 报错 let a = 1;} 在循环块中使用let声明了a变量，在声明之前使用会报错。这并不是说明使用let声明的变量不会进行提升，实际上a也会被提升到作用域顶端。只是从a被复制到作用域顶端这段范围被称为变量a的临时性死区，在这段区域内是无法访问变量a的。变量提升并不是一个缺陷，而是为了解决一些问题而存在的，例如：123456function a() { b()}function b() { a()} 类似这种我中有你你中有我的情况，就可以利用变量提升很好的解决。 3、const不可变const和let一样，也具有变量提升和临时性死区的特点。他们两唯一不同的是const声明的变量不允许改变（常量）。12const a = 10;a = 1 // 报错 如果const定义了一个引用数据类型：12const a = {name: \"hello\"};a.name = \"world\"; 这样的改变是允许的，因为此时a是存在于栈区的一个名字，由于const的原因无法改变a对应栈区的内容，但是他所指向的对象是存放在堆区的，所以改变a.name是被允许的。 4、挂载对象\bvar和let/const还有一个明显的区别，就是var声明的变量是挂载到window下，可以通过window来访问，而let/const不行。12345var a = 1let b = 1const c = 1console.log(window.a) // 1console.log(window.b, window.c) // undefined","link":"/2017/12/02/JavaScript中的-var、let、const/"},{"title":"JavaScript的静态词法作用域","text":"无论是JavaScript或其他编程语言，都会存在“作用域”的概念。它规定了代码对变量的访问权限以及如何查找变量。词法作用域分为静态作用域和动态作用域，JavaScript所采用的是静态词法作用域。 何为静态词法作用域？123456789var value = 1;function test1() { console.log(value) // 1}function test2(){ var value = 2 test1(1);}test2() test1函数实在test2函数的作用域中调用的，value已经在test2函数作用域中存在，但是test1任然输出了1，也就是全局作用于中的value值。 这就是静态作用域最好的表示，在JS引擎对代码进行静态词法分析的时候，已经将每个变量的词法作用域确定下来了，且在动态运行的过程中不随着调用栈的变化而改变。反之动态词法作用域相信大家也能理解了。 欺骗词法作用域JavaScript其实还能够在程序运行的过程中来修改词法作用域，但因为性能原因不建议使用。 1. evaleval函数可以接受一个字符串作为参数，并将其内容转换为代码存放于程序的相应位置。可想而知，这种动态生成的代码如果带有变量声明，那么程序的词法作用域环境也会发生相应的变化。123456var b = 1;function foo(str){ eval(str) console.log(b) // 2}foo(\"var b = 2;\") 在foo函数中，对str参数进行了执行，相当于当前行变成了 var b = 2，最终输出了2。这行代码执行后声明了一个b变量，对上层作用域的变量b进行了遮蔽。所以console.log执行时，只在foo的内部找到了b，无法找到外部的b。 2. withwith用来避免重复引用对象的快捷方式，例如：1234567891011let obj = { a: 1, b: 2, c: 3 }obj.a / obj.a / obj.c // 访问起来吃力with(obj){ a= 3; b= 4; c= 5; } 如此，我们在操作对象的时候就可以省很多力，那么如何通过with来更改词法作用域？123456789101112function setData(obj){ with(obj){ a = 10 }}var o1 = { a: 3}var o2 = { b: 1}setData(o1)console.log(o1.a) // 10setData(o2)console.log(o2.a) // undifinedconsole.log(a) // 10 发生泄漏 在with的作用域中，如果对obj没有的属性进行赋值，便会在全局作用域下生成新的变量（修改了词法作用域）。 总结JavaScript是一种“解释型”语言，在到达浏览器之前不会进行编译和构建。所以它追求的是每一行能够尽快的编译执行完毕，不会对DOM造成阻塞。所以在编译的过程中要尽可能的优化代码， 减少运行时资源的消耗。 而我们使用类似eval/with去欺骗（修改）了词法作用域，会让浏览器减少相应代码块的优化，因为即使做了静态词法作用域分析，也会在将来被这类操作修改，没有意义。","link":"/2018/05/20/JavaScript的静态词法作用域/"},{"title":"JavaScript原型链继承和Class继承","text":"在JavaScript中如果想要实现继承，都是要借助原型链特性。class是ES6新推出的关键字，但在JavaScript中并不存在类的概念，class关键字只是一种语法糖，其本质还是函数。 1、组合继承1234567891011121314151617// 父类构造函数function Animal(name) { this.name = name;}// 为父类原型增加eat方法Animal.prototype.eat = ()=&gt; { console.log('can eat');}// 子类构造函数function Dog(name) { // 调用父类构造函数，改变this指向子类 Animal.call(this, name);}// 将子类原型指向父类实例对象Dog.prototype = new Animal();const d = new Dog();d.eat(); 组合继承结合了构造函数继承和原型继承，使子类独享了属性也继承了父类方法。是JavaScript较常用的继承方式。但是这种方式有一定的内存浪费，由于子类原型指向了父类实例对象，父类的实例对象上的属性便会存在于原型链上，而这些属性已经在子类上存在。 2、寄生组合继承组合继承的缺陷是由于设置子类原型时，调用了父类的构造函数。那么寄生组合继承可以通过Object.create来解决这个问题。1234567891011121314151617function Animal(name) { this.name = name;}Animal.prototype.eat = ()=&gt; { console.log('can eat');}function Dog(name) { Animal.call(this, name);}// 使用Object.create 基于父类原型改写construct指向来创建实例Dog.prototype = Object.create(Animal.prototype, { construct: { value: Dog }});const d = new Dog(\"Hello\");d.eat(); 如此，父类的原始构造函数就不会再执行。 3、class继承12345678910111213141516class Animal{ constructor(name){ this.name = name; } eat() { console.log('can eat'); }}class Dog extends Animal{ constructor(name) { // 必须调用super方法 super(name) }}const d = new Dog(\"Hello\");d.eat(); 在使用class进行继承的时候，子类的构造方法必须要调用super方法，相当于原型链继承中的Animal.call(this, name)。归根究底，class只是一种语法糖，它使得JavaScript的写法更加的面向对象，更具有可读性。","link":"/2018/06/25/JavaScript原型链继承和Class继承/"},{"title":"React网络请求的时间点分析","text":"React无疑是目前最流行的前端View库之一。在业务开发中，开发者经常会因为网络请求时间点的选择而纠结，那么这篇文章一定会给你带来一些帮助。 本文所提到的网络请求主要是组件初始化请求，不包括触发式请求（比如点赞请求、评论请求等）。 首先我们需要明确的是可进行网络请求的React类组件生命周期：1234constructor()componentWillMount()render()componentDidMount() React在官方文档中提到，componentDidMount是比较适合进行网络请求的地方：大多数情况下，在didMount中进行网络请求确实比较稳妥，不太容易出现问题。但在实际开发中，可能会由于需求的不同而存在更多的请求节点选择。 同步网络请求同步的请求很少出现。这类请求最好在constructor和willMount阶段进行，因为同步请求会阻塞React组件的渲染及浏览器事件。在组件渲染完毕，会调用didMount方法。如果在这个时间发送同步请求，务必会阻塞用户和页面的交互，造成页面假死的现象。而在render之前，constructor和willMount均未渲染出页面，此时进行同步请求也只会使用户觉得组件或页面正在加载中。 异步网络请求异步网络请求是在开发中最常见的，它并不会阻塞组件的渲染。将这类请求放在constructor和willMount中效率会更高。异步请求在取得response后通常会使用setState来触发render。didMount调用时实际上已经render过一次，如果在didMount中请求数据，至少会经历两次render（假设请求成功）。setState实际上是将更新的状态放进了组件的__pendingStateQueue队列。速度足够快的情况下，在constructor和willMount中的请求能够在第一次render前进行setState，此时setState并不会触发渲染，而是会在组件进行第一次render的时候统一渲染，实际只进行了一次render。如果没有在第一次render前获取到response，最多也只会和didMount中请求一样的效果，进行两次渲染。综上，将异步请求放在constructor和willMount中会显得更加的高效。 在construcor中发出的异步请求（microTask）如果足够快，会在组件没有mounted前调用setState，这个时候是不成功的，必须直接使用this.state = {} 的形式设置state，这需要增加额外的判断。 不涉及UI渲染的网络请求我们一般不依赖这类请求的response，只需要强调请求的发送。所以比较适合在constructor阶段完成。 SSR（服务端渲染）如果网站考虑SSR的话，那么网络请求要尽可能的放到didMount中，因为didMount在SSR的过程中并不会被执行，且SSR生成HTML的过程中也不需要执行网络请求（没有意义）。 Fiber reconcilerFiber是React16所采用的协调算法，可以通过这篇文章深入了解。使用Fiber后，组件render前的生命周期方法可能会被打断，也就意味这这些方法可能会被多次执行。因此，在React16后，初始网络请求都要尽量在didMount中执行。 总结","link":"/2019/02/23/React和Vue网络请求的时间点分析/"},{"title":"enzyme模拟checkbox选中与取消","text":"在涉及到checkbox表单元素的单测时，我们会直观的模拟input元素的click事件以触发元素值的改变。但在使用enzyme进行组件单测时却行不通。 正确的做法正确的做法是模拟input元素的change事件，传递想要的target.value。123456789101112import React from 'react'import { mount } from 'enzyme'it('should change checkbox value', () =&gt; { const changeFn = e =&gt; console.log(e.target.checked) const wrapper = mount(&lt;input type=\"checkbox\" onChange={changeFn} /&gt;) wrapper.find('input').simulate('click', { target: { value: true, }, })}) 为什么？enzyme的事件模拟系统并不是我们所想象的那样，操作真实的dom来触发dom级事件。而是简单的将simulate转发到props上的相应func。所以在测试过程中如果我们需要为组件模拟相应的事件，只需要关注组件props上onEventName中的EventName。就像以下情况：12&lt;input onBlur={handleBlur} /&gt; // simulate('blur')&lt;div contentEditable onInput={handleInput}&gt;&lt;/div&gt; // simulate('input')","link":"/2019/02/24/enzyme模拟checkbox选中与取消/"},{"title":"从浏览器输入URL到页面加载完毕发生了什么","text":"当我们在浏览器中输入URL后，背后发生了很多巧妙的处理和数据的传递。这个知识点在面试的时候经常被问到，因为它不仅仅考察了求职人员前端技术水平，更查验了他对整个网络通信知识体系的宏观理解。 1、针对域名进行DNS解析如果输入的URL是域名而不是IP，会进行这一步的DNS解析操作。解析的目的是为了将域名转换成IP，然后再使用TCP/IP来进行寻址访问。浏览器解析DNS主要会经过以下几步： 检查浏览器自身DNS记录 检查操作系统DNS记录（hosts文件） 通信服务商（ISP）DNS记录 查询域名服务器在查询域名服务器之前还有一步是查询ISP的DNS记录，这里面存放了许多的DNS缓存条目。这些条目会不定期的刷新，会是一小时也可能会是一整天。所以一般我们新注册的域名绑定IP后，很快就能够解析成功，是因为直接去到域名服务器上查询，而如果是更改域名记录则会需要等待一定的时间才能解析成功。 2、TCP三次握手建立通信当域名解析成功获得IP地址后，会通过TCP和目标服务器建立TCP通信。建立通信的条件就是客户机与服务器进行三次握手成功： 客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。 3、HTTP请求与响应当客户机和服务器之间的TCP链路建立成功之后，客户机便会开始发送HTTP请求报文，请求报文主要由报文首部和报文主体组成： 报文首部（URL、请求方法、HTTP版本等信息） 报文主体（formdata等数据）在服务器接收到请求后会进行一系列处理后将数据通过HTTP响应报文的形式返回，格式与请求报文相同。 4、TCP四次挥手断开连接HTTP是一种无状态协议，在每一次通信完毕之后会将TCP连接关闭。但是在实际情况下，一个网页发起HTTP请求是非常频繁的，一张图片、一个文本、一段数据，而建立TCP连接的开销又是非常耗费资源且没有必要的。所以在HTTP1.1中，对这种短连接进行了改善，增加了长连接的特性。这里的长连接并不是说像WebSocket一样持久连接，而是客户机和服务器之间的TCP连接会在数据传输之后维持一段时间，若再次发生数据传递，则会就地取材利用该链路进行传输，反之则将TCP连接关闭。在TCP关闭连接的时候，也需要经历四次挥手： 总结来说，上述提到建立TCP连接的三次握手，是用来保障通讯双方有通信的基础，断开时的四次挥手，用来保障通讯双方可以安全的回收TCP通信的系统资源。 5、浏览器解析渲染浏览器在接收到HTTP响应数据后，会首先进行解析。在HTTP1.1中，数据是采用字符串来进行传输的，也就意味着浏览器从HTTP响应报文的报文主体中取到的是字符串。以html文件为例，浏览器会将字符串解析成若干个节点（Node），再将节点组合成DOM Tree。在解析html文件的过程中如果遇到外链的CSS或Script文件，则会去异步请求这些资源。在CSS文件响应完毕后，会在解析DOM Tree的同时将CSS解析成CSS Tree。之后会把两者合并成Render Tree。\b随后渲染引擎将基于此来进行布局和渲染。 在浏览器处理URL的过程中，还有很多值得深入学习的地方，比如HTTPS、加密技术、JS引擎等，本文只是从宏观的角度来对这个过程进行简要的介绍。","link":"/2018/08/18/从浏览器输入URL到页面加载完毕发生了什么/"},{"title":"从零开始搭建Webpack+Vue项目","text":"在使用Vue开发时，我们大多数会使用官方的vue-cli，主要特点包括： 基于webpack构建，带有合理的默认配置 快速零配置原型开发 包含丰富的官方插件集合通过它我们可以快速开发一个完整的系统。本文就带领大家从零开始来搭建一个最精简、可运行、基于webpack3构建的Vue(2.x)项目。这能让我们了解到webpack和vue在我们日常开发中所处的地位，帮助我们学习或回顾webpack一些配置属性。 1、构建Node环境我们需要先使用npm包管理工具构建项目所需的Node环境，安装一些必要的依赖包。 npm init - 初始化项目，自动创建package.json描述文件 npm i -D webpack@3.1 vue vue-loader vue-template-compiler webpack - 模块打包工具，用于将我们构建的项目打包，@3.1表示制定版本号 vue - MVVM的视图层框架，用它来支持我们的vue相关特性 vue-loader - webpack的loader，使我们可以使用单文件组件的方式编写vue vue-template-compiler - vue的模板编译工具，用于将vue template内容编译成render function 2、编写所需index.html和main.js index.html作为SPA（单页 应用）的载体，未来需要引入打包完成后的文件。 main.js作为webpack的入口文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;&lt;title&gt;Webpack Vue&lt;/title&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;script defer src=\"./dist/bundle.js\"&gt;&lt;/script&gt;&lt;!-- defer的目的是为了将dom解析完成后在执行js文件（延迟执行），也可以放在&lt;/body&gt;之前 --&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12const dom = document.getElementById(\"app\") console.log(dom) 3、编写webpack配置文件123456789101112\"use strict\"const path = require(\"path\")module.exports = { // 入口文件 entry: './src/main.js', // 最终输出 ，在index.html中引入 output: { filename: \"bundle.js\", // 使用path合成绝对路径 path: path.resolve(__dirname, \"../dist\") }} 将上述配置保存在build/webpack.config.js下，切换到项目根目录运行webpack –config ./build/webpack.config.js命令，webpack就会根据配置文件来进行打包。 为了方便编译，我们为npm script加入webpack命令：1\"build\": \"webpack --config ./build/webpack.config.js\" 项目目录增加了biuld及dist后： 这个时候在浏览器中运行index.html便会发现输出了DOM，接下来我们就可以为项目添加Vue支持了。 4、添加 Vue 支持1、编写App.vue1234567891011121314151617181920212223&lt;template&gt;&lt;div id=\"root\"&gt; &lt;h3&gt;v-for render list&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in list\" :key=\"index\" &gt; {{index}} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"App\", data: function () { return { list: new Array(5) } }}&lt;/script&gt; 在App.vue中我们使用到了vue的指令、数据响应式等特性。 2、为webpack添加vue-loader1234567891011121314151617\"use strict\"const path = require(\"path\")const {VueLoaderPlugin} = require(\"vue-loader\") module.exports = {...module: { rules: [ { test: /.vue$/, loader: \"vue-loader\" } ]},plugins: [ new VueLoaderPlugin()]} 在module中添加vue文件的解析规则，文件后缀为vue的文件采用vue-loader解析； 添加VueLoaderPlugin，这个插件是必须的，它的职责是将你定义过的其它规则复制并应用到 .vue 文件里相应语言的块。例如，如果你有一条匹配 /\\.js$/ 的规则，那么它会应用到 .vue 文件里的 script 块。 3、改写main.js是时候让index.html和App.vue发生关联了。123456789import Vue from &amp;quot;vue&amp;quot;import App from \"./App.vue\"export default new Vue({ el: \"#app\", components: { App }, template: `&lt;App /&gt;`}) 初始化Vue，将其挂在在#app上，并且将App组件渲染其中。这个时候再次运行npm run build进行编译，well done。刷新页面，发现报错了！ 这是因为Vue分为运行时版本和编译+运行时版本。运行时版本要比较小，前提是已经生成了编译后的render function字符串。在mins.js初始化Vue时，我们使用了template属性，需要引入带编译器的完整版的vue.esm.js，可以再webpack.config.js中设置vue别名来解决这个问题：12345resolve: { alias: { \"vue$\": \"vue/dist/vue.esm.js\" }}, 再次编译后就可以成功查看页面。另一种解决方案更直接，在main.js中将template属性设置的方式改为render function的方式：12// template: `&lt;App /&gt;`render: h=&gt;h(App) 那么在App.vue中的template呢？其实App.vue中的template已经被vue-loader处理了。 至此我们已经使用了最少的代码构建了一个简单可用的webpack+vue项目。另外可以根据自己需要为项目添加webpack-dev-server及babel的支持。","link":"/2018/08/03/从零开始搭建Webpack-Vue项目/"},{"title":"在less中遍历数组元素","text":"在Less中并没有对数组遍历的原生支持，我们可以通过mixin递归的方式来实现遍历。 1、定义数组元素1@colors: red, green, blue, black; 2、获取数组元素长度1@length: length(@color); 3、数组元素取值1@item: extract(@colors, @index); 4、遍历123456789@colors: red, green, blue, black;.for(@data, @i: 1) when(@i =&lt; length(@data)) { @item: extract(@data, @i); div { background: @item; } .for(@data, (@i + 1));}.for(@colors); 以上的less会被编译成以下css:123456789101112div { background: red;}div { background: green;}div { background: blue;}div { background: black;}","link":"/2019/02/24/在less中遍历数组元素/"},{"title":"将 vue 插件发布到 npm","text":"1、准备好 Vue 插件在发布 npm 之前，你需要按照Vue插件开发手册开发完成你的 Vue 插件。 2、创建一个简单的项目通过 webpack-simple 来新建一个简单的项目。1vue init webpack-simple [your plugin name] 目录结构如下图： 3、封装插件1、创建 src/lib 目录，建立index.js文件 2、填充相应内容1234567891011121314/** 按照 Vue查看开发手册 开发的插件*/const yourPlugin = { install: function(Vue, options) { // .... }};/***** 新增内容 *****/if (typeof window !== 'undefined' &amp;&amp; window.Vue) { window.Vue.use(yourPlugin)}export default yourPlugin;/***** 新增内容 *****/ 如果你的插件依赖其他 css 或者 库， 同样可以在 index.js 中 import。 4、配置1、webpack配置修改webpack.config.js123456789101112module.exports = { entry: './src/lib/index.js', output: { path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'plugin-name.js', library: \"plugin-name\", libraryTarget: 'umd', umdNamedDefine: true }, // ...} entry 修改入口文件的路径 output 配置最终输出的代码 filename 输出的文件名称，修改成插件名称 library 新增导出库的名称 libraryTarget 新增导出库的方式 umdNamedDefine 对AMD模块重命名 webpack.config.js 按照上述配置完毕，可以通过 npm run build 来进行构建。 2、package.json配置1234567891011{ //... \"license\": \"MIT\", \"private\": false, \"main\": \"dist/vue-easy-loading.js\", \"repository\": { \"type\": \"git\", \"url\": \"https://github.com/...\" } // ...} private 修改成false, 表示公开库 main 修改成构建后的输入文件 repository 可以写上库的 github 地址 5、发布到npm npm login 来登录 npm 账户，或者注册 在项目根目录 npm publish 发布项目 最后如果上述步骤顺利完成，开发者就可以通过npm install YourPluginName来安装到本地，通过ES6 import的方式来引入并使用。","link":"/2018/04/23/将-vue-插件发布到-npm/"},{"title":"使用 CSS3 Grid Layout 实现自适应布局","text":"CSS Grid Layout 是 CSS 中非常强大的布局系统，与 flexbox 很相似。但 flexbox 主要针对一维布局， grid layout 能够很好的作用于二维布局。本文将使用 grid layout 的若干属性来创建一个自适应布局，体会一下在屏幕适配方面 grid layout 给我们带来的便携。如果你还没有学习或接触过 gird layout ，可以先通过这篇文章来学习一下。 1、HTML结构123456&lt;div class=\"container\"&gt; &lt;div class=\"header\"&gt;Header&lt;/div&gt; &lt;div class=\"slider\"&gt;Slider&lt;/div&gt; &lt;div class=\"content\"&gt;Content&lt;/div&gt; &lt;div class=\"footer\"&gt;Footer&lt;/div&gt;&lt;/div&gt; 最外围通过一个容器包裹，之后会通过 CSS 将它设置成一个网格容器。其中的子元素称为 网格项。Grid Layout 有个尤为显著的特点：网格容器中的网格项排布，与实际 HTML 结构无关。flexbox 也拥有一样的特性，这种特性为自适应布局提供了很好的支持。 2、CSS设置container 网格容器设置12345678910.container { display: grid; grid-template-columns: repeat(12, 1fr); grid-template-rows: 80px 500px 80px; grid-gap: 10px; grid-template-areas: \"h h h h h h h h h h h h\" \"s s s c c c c c c c c c\" \"f f f f f f f f f f f f\";} display 将 div 变成网格容器。 grid-template-columns 和 grid-template-rows 指定了行列的排布， repeat函数的作用是将1fr 重复12次，即将列进行12等分。 gird-gap 设置了网格项之间的间隙。 grid-template-areas 是自适应布局的关键，首先将每个网格项命名，再将网格项的排布通过上面这种写法表示出来。 网格项的设置12345678910111213141516.container .header { grid-area: h; background: burlywood;}.container .footer { grid-area: f; background: aquamarine;}.container .slider { grid-area: s; background: rebeccapurple;}.container .content { grid-area: c; background: green;} grid-area 用来给每个网格项命名 3、屏幕自适应grid-template-areas 是实现自适应布局的关键，网格项的布局是通过它来指定的，所以实现屏幕自适应的思路就是，通过 CSS3 媒体查询，在屏幕大小发生变化的时候来改编 grid-template-areas 的值。12345678910111213141516171819@media screen and (max-width: 800px) { .container{ grid-template-areas: \"h h h h h h s s s s s s\" \"c c c c c c c c c c c c\" \"f f f f f f f f f f f f\"; }}@media screen and (max-width:500px) { .slider{ display: none; } .container{ grid-template-areas: \"h h h h h h h h h h h h\" \"c c c c c c c c c c c c\" \"f f f f f f f f f f f f\"; }}","link":"/2018/01/13/使用-CSS3-Grid-Layout-实现自适应布局/"},{"title":"纯CSS 实现汉堡式菜单与返回箭头转换动画","text":"汉堡式菜单，由三根平行的直线组成；返回箭头，由两个对称倾斜的箭帽和一条水平直线组成。下面我们就通过使用 CSS 来实现上图的转换效果。实际效果见banner。 HTML1234567&lt;div class=\"toggleContainer\"&gt; &lt;div class=\"inner\"&gt; &lt;span class=\"line line-first\"&gt;&lt;/span&gt; &lt;span class=\"line line-second\"&gt;&lt;/span&gt; &lt;span class=\"line line-third\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; span.line 表示三条直线 div.inner 负责包裹三条直线，直线的位置会相对于它进行变化 toggleContainer 负责最外围的包裹，用来设置 padding，起美化作用 白色直线的 CSS1234567891011121314151617181920212223242526.inner .line{ /** 使其可设置大小 **/ display: inline-block; /** 长度扩展整个父元素 **/ width: 100%; height: 8px; /** 用来设置动画 **/ transition: all .5s; /** 相对于 .inner 进行定位**/ position: absolute; left: 0; background: #fff;}.inner .line-first{ /** 第一条直线居上 **/ top: 0;}.inner .line-second{ /** 第二条直线垂直居中 **/ top: 50%; transform: translate(0, -50%);}.inner .line-third{ /** 第三条直线居下 **/ bottom: 0;} div.inner 和 div.toggleContainer 的CSS1234567891011121314151617.inner{ /** 填充整个父元素 **/ width: 100%; height: 100%; /** 使其子元素相对其进行定位 **/ position: relative;}.toggleContainer { /** 设置大小 **/ width: 80px; height: 70px; /** 增加内边距，美观 **/ padding: 14px 10px; box-sizing: border-box; background: #222; cursor: pointer;} 经过上面的设置后，已经能够看到一个汉堡菜单了，接下来就需要编写 hover 时的 CSS，让三条线动起来。 给三条线做CSS动画1234567891011121314151617181920/** 首先让第一条线动起来 **/.toggleContainer:hover .line-first{ /** 设置动画时间和属性 **/ transition: all 0.5s; /** 缩短长度 **/ width: 50%; /** 旋转-45度 **/ transform: rotate(-45deg); /** 往下移动，与第二条线重叠 **/ top: 5px; left: -1px;}/** 再让第三条线动起来 **/.toggleContainer:hover .line-third{ transition: all 0.5s; width: 50%; transform: rotate(45deg); bottom: 5px; left: -1px;} 最后有很多简单的线性变化都可以使用 CSS和HTML 来实现，找出其中的位置、角度、大小等变化，操作起来就非常容易了。","link":"/2018/07/18/纯CSS-实现汉堡式菜单与返回箭头转换动画/"}],"tags":[{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"作用域","slug":"作用域","link":"/tags/作用域/"},{"name":"原型链","slug":"原型链","link":"/tags/原型链/"},{"name":"生命周期","slug":"生命周期","link":"/tags/生命周期/"},{"name":"网络请求","slug":"网络请求","link":"/tags/网络请求/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"jest","slug":"jest","link":"/tags/jest/"},{"name":"enzyme","slug":"enzyme","link":"/tags/enzyme/"},{"name":"URL","slug":"URL","link":"/tags/URL/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"Grid Layout","slug":"Grid-Layout","link":"/tags/Grid-Layout/"}],"categories":[{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"单元测试","slug":"单元测试","link":"/categories/单元测试/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}
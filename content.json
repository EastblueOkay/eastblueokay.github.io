{"pages":[],"posts":[{"title":"React网络请求的时间点分析","text":"React无疑是目前最流行的前端View库之一。在业务开发中，开发者经常会因为网络请求时间点的选择而纠结，那么这篇文章一定会给你带来一些帮助。 本文所提到的网络请求主要是组件初始化请求，不包括触发式请求（比如点赞请求、评论请求等）。 首先我们需要明确的是可进行网络请求的React类组件生命周期：1234constructor()componentWillMount()render()componentDidMount() React在官方文档中提到，componentDidMount是比较适合进行网络请求的地方：大多数情况下，在didMount中进行网络请求确实比较稳妥，不太容易出现问题。但在实际开发中，可能会由于需求的不同而存在更多的请求节点选择。 同步网络请求同步的请求很少出现。这类请求最好在constructor和willMount阶段进行，因为同步请求会阻塞React组件的渲染及浏览器事件。在组件渲染完毕，会调用didMount方法。如果在这个时间发送同步请求，务必会阻塞用户和页面的交互，造成页面假死的现象。而在render之前，constructor和willMount均未渲染出页面，此时进行同步请求也只会使用户觉得组件或页面正在加载中。 异步网络请求异步网络请求是在开发中最常见的，它并不会阻塞组件的渲染。将这类请求放在constructor和willMount中效率会更高。异步请求在取得response后通常会使用setState来触发render。didMount调用时实际上已经render过一次，如果在didMount中请求数据，至少会经历两次render（假设请求成功）。setState实际上是将更新的状态放进了组件的__pendingStateQueue队列。速度足够快的情况下，在constructor和willMount中的请求能够在第一次render前进行setState，此时setState并不会触发渲染，而是会在组件进行第一次render的时候统一渲染，实际只进行了一次render。如果没有在第一次render前获取到response，最多也只会和didMount中请求一样的效果，进行两次渲染。综上，将异步请求放在constructor和willMount中会显得更加的高效。 在construcor中发出的异步请求（microTask）如果足够快，会在组件没有mounted前调用setState，这个时候是不成功的，必须直接使用this.state = {} 的形式设置state，这需要增加额外的判断。 不涉及UI渲染的网络请求我们一般不依赖这类请求的response，只需要强调请求的发送。所以比较适合在constructor阶段完成。 SSR（服务端渲染）如果网站考虑SSR的话，那么网络请求要尽可能的放到didMount中，因为didMount在SSR的过程中并不会被执行，且SSR生成HTML的过程中也不需要执行网络请求（没有意义）。 Fiber reconcilerFiber是React16所采用的协调算法，可以通过这篇文章深入了解。使用Fiber后，组件render前的生命周期方法可能会被打断，也就意味这这些方法可能会被多次执行。因此，在React16后，初始网络请求都要尽量在didMount中执行。 总结","link":"/2019/02/23/React和Vue网络请求的时间点分析/"},{"title":"JavaScript的静态词法作用域","text":"无论是JavaScript或其他编程语言，都会存在“作用域”的概念。它规定了代码对变量的访问权限以及如何查找变量。词法作用域分为静态作用域和动态作用域，JavaScript所采用的是静态词法作用域。 何为静态词法作用域？123456789var value = 1;function test1() { console.log(value) // 1}function test2(){ var value = 2 test1(1);}test2() test1函数实在test2函数的作用域中调用的，value已经在test2函数作用域中存在，但是test1任然输出了1，也就是全局作用于中的value值。 这就是静态作用域最好的表示，在JS引擎对代码进行静态词法分析的时候，已经将每个变量的词法作用域确定下来了，且在动态运行的过程中不随着调用栈的变化而改变。反之动态词法作用域相信大家也能理解了。 欺骗词法作用域JavaScript其实还能够在程序运行的过程中来修改词法作用域，但因为性能原因不建议使用。 1. evaleval函数可以接受一个字符串作为参数，并将其内容转换为代码存放于程序的相应位置。可想而知，这种动态生成的代码如果带有变量声明，那么程序的词法作用域环境也会发生相应的变化。123456var b = 1;function foo(str){ eval(str) console.log(b) // 2}foo(\"var b = 2;\") 在foo函数中，对str参数进行了执行，相当于当前行变成了 var b = 2，最终输出了2。这行代码执行后声明了一个b变量，对上层作用域的变量b进行了遮蔽。所以console.log执行时，只在foo的内部找到了b，无法找到外部的b。 2. withwith用来避免重复引用对象的快捷方式，例如：1234567891011let obj = { a: 1, b: 2, c: 3 }obj.a / obj.a / obj.c // 访问起来吃力with(obj){ a= 3; b= 4; c= 5; } 如此，我们在操作对象的时候就可以省很多力，那么如何通过with来更改词法作用域？123456789101112function setData(obj){ with(obj){ a = 10 }}var o1 = { a: 3}var o2 = { b: 1}setData(o1)console.log(o1.a) // 10setData(o2)console.log(o2.a) // undifinedconsole.log(a) // 10 发生泄漏 在with的作用域中，如果对obj没有的属性进行赋值，便会在全局作用域下生成新的变量（修改了词法作用域）。 总结JavaScript是一种“解释型”语言，在到达浏览器之前不会进行编译和构建。所以它追求的是每一行能够尽快的编译执行完毕，不会对DOM造成阻塞。所以在编译的过程中要尽可能的优化代码， 减少运行时资源的消耗。 而我们使用类似eval/with去欺骗（修改）了词法作用域，会让浏览器减少相应代码块的优化，因为即使做了静态词法作用域分析，也会在将来被这类操作修改，没有意义。","link":"/2018/05/20/JavaScript的静态词法作用域/"}],"tags":[{"name":"生命周期","slug":"生命周期","link":"/tags/生命周期/"},{"name":"网络请求","slug":"网络请求","link":"/tags/网络请求/"},{"name":"作用域","slug":"作用域","link":"/tags/作用域/"}],"categories":[{"name":"React","slug":"React","link":"/categories/React/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}
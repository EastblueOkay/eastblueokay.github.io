{"pages":[],"posts":[{"title":"JavaScript的静态词法作用域","text":"无论是JavaScript或其他编程语言，都会存在“作用域”的概念。它规定了代码对变量的访问权限以及如何查找变量。词法作用域分为静态作用域和动态作用域，JavaScript所采用的是静态词法作用域。 何为静态词法作用域？123456789var value = 1;function test1() { console.log(value) // 1}function test2(){ var value = 2 test1(1);}test2() test1函数实在test2函数的作用域中调用的，value已经在test2函数作用域中存在，但是test1任然输出了1，也就是全局作用于中的value值。 这就是静态作用域最好的表示，在JS引擎对代码进行静态词法分析的时候，已经将每个变量的词法作用域确定下来了，且在动态运行的过程中不随着调用栈的变化而改变。反之动态词法作用域相信大家也能理解了。 欺骗词法作用域JavaScript其实还能够在程序运行的过程中来修改词法作用域，但因为性能原因不建议使用。 1. evaleval函数可以接受一个字符串作为参数，并将其内容转换为代码存放于程序的相应位置。可想而知，这种动态生成的代码如果带有变量声明，那么程序的词法作用域环境也会发生相应的变化。123456var b = 1;function foo(str){ eval(str) console.log(b) // 2}foo(\"var b = 2;\") 在foo函数中，对str参数进行了执行，相当于当前行变成了 var b = 2，最终输出了2。这行代码执行后声明了一个b变量，对上层作用域的变量b进行了遮蔽。所以console.log执行时，只在foo的内部找到了b，无法找到外部的b。 2. withwith用来避免重复引用对象的快捷方式，例如：1234567891011let obj = { a: 1, b: 2, c: 3 }obj.a / obj.a / obj.c // 访问起来吃力with(obj){ a= 3; b= 4; c= 5; } 如此，我们在操作对象的时候就可以省很多力，那么如何通过with来更改词法作用域？123456789101112function setData(obj){ with(obj){ a = 10 }}var o1 = { a: 3}var o2 = { b: 1}setData(o1)console.log(o1.a) // 10setData(o2)console.log(o2.a) // undifinedconsole.log(a) // 10 发生泄漏 在with的作用域中，如果对obj没有的属性进行赋值，便会在全局作用域下生成新的变量（修改了词法作用域）。 总结JavaScript是一种“解释型”语言，在到达浏览器之前不会进行编译和构建。所以它追求的是每一行能够尽快的编译执行完毕，不会对DOM造成阻塞。所以在编译的过程中要尽可能的优化代码， 减少运行时资源的消耗。 而我们使用类似eval/with去欺骗（修改）了词法作用域，会让浏览器减少相应代码块的优化，因为即使做了静态词法作用域分析，也会在将来被这类操作修改，没有意义。","link":"/2018/05/20/JavaScript的静态词法作用域/"},{"title":"CSS预处理器中使用Webpack alias配置","text":"在使用 webpack 构建项目时，经常会使用到 resolve.alias 的功能。它可以用来创建 import 或 require 的别名，使得模块引入变得更简单。123alias: { '@': 'src/components'} 现在，可以替换替换原有的导入路径方式：1234// beforeimport component from \"src/components/component\"// afterimport component from \"@/component\" 在CSS预处理器的@import中使用alias@import存在于 css 中，而 css 是由 css-loader 来进行处理的，所以在处理过程中并不能使用 webpack loader 的 alias 配置。下面的引入将不会生效：1@import \"@/reset.css\" 使用 ~ 标识符想要在 css 中使用 alias，可以采用如下解决方案：1@import \"~@/reset.css\" ~的作用是告诉 webpack，当前 import 的路径是使用 alias 配置进行导入。可以点击这里查看该css-loader Issues详情","link":"/2018/04/23/CSS预处理器中使用Webpack-alias配置/"},{"title":"使用 CSS3 Grid Layout 实现自适应布局","text":"CSS Grid Layout 是 CSS 中非常强大的布局系统，与 flexbox 很相似。但 flexbox 主要针对一维布局， grid layout 能够很好的作用于二维布局。本文将使用 grid layout 的若干属性来创建一个自适应布局，体会一下在屏幕适配方面 grid layout 给我们带来的便携。如果你还没有学习或接触过 gird layout ，可以先通过这篇文章来学习一下。 1、HTML结构123456&lt;div class=\"container\"&gt; &lt;div class=\"header\"&gt;Header&lt;/div&gt; &lt;div class=\"slider\"&gt;Slider&lt;/div&gt; &lt;div class=\"content\"&gt;Content&lt;/div&gt; &lt;div class=\"footer\"&gt;Footer&lt;/div&gt;&lt;/div&gt; 最外围通过一个容器包裹，之后会通过 CSS 将它设置成一个网格容器。其中的子元素称为 网格项。Grid Layout 有个尤为显著的特点：网格容器中的网格项排布，与实际 HTML 结构无关。flexbox 也拥有一样的特性，这种特性为自适应布局提供了很好的支持。 2、CSS设置container 网格容器设置12345678910.container { display: grid; grid-template-columns: repeat(12, 1fr); grid-template-rows: 80px 500px 80px; grid-gap: 10px; grid-template-areas: \"h h h h h h h h h h h h\" \"s s s c c c c c c c c c\" \"f f f f f f f f f f f f\";} display 将 div 变成网格容器。 grid-template-columns 和 grid-template-rows 指定了行列的排布， repeat函数的作用是将1fr 重复12次，即将列进行12等分。 gird-gap 设置了网格项之间的间隙。 grid-template-areas 是自适应布局的关键，首先将每个网格项命名，再将网格项的排布通过上面这种写法表示出来。 网格项的设置12345678910111213141516.container .header { grid-area: h; background: burlywood;}.container .footer { grid-area: f; background: aquamarine;}.container .slider { grid-area: s; background: rebeccapurple;}.container .content { grid-area: c; background: green;} grid-area 用来给每个网格项命名 3、屏幕自适应grid-template-areas 是实现自适应布局的关键，网格项的布局是通过它来指定的，所以实现屏幕自适应的思路就是，通过 CSS3 媒体查询，在屏幕大小发生变化的时候来改编 grid-template-areas 的值。12345678910111213141516171819@media screen and (max-width: 800px) { .container{ grid-template-areas: \"h h h h h h s s s s s s\" \"c c c c c c c c c c c c\" \"f f f f f f f f f f f f\"; }}@media screen and (max-width:500px) { .slider{ display: none; } .container{ grid-template-areas: \"h h h h h h h h h h h h\" \"c c c c c c c c c c c c\" \"f f f f f f f f f f f f\"; }}","link":"/2018/01/13/使用-CSS3-Grid-Layout-实现自适应布局/"},{"title":"React网络请求的时间点分析","text":"React无疑是目前最流行的前端View库之一。在业务开发中，开发者经常会因为网络请求时间点的选择而纠结，那么这篇文章一定会给你带来一些帮助。 本文所提到的网络请求主要是组件初始化请求，不包括触发式请求（比如点赞请求、评论请求等）。首先我们需要明确的是可进行网络请求的React类组件生命周期：1234constructor()componentWillMount()render()componentDidMount() React在官方文档中提到，componentDidMount是比较适合进行网络请求的地方：大多数情况下，在didMount中进行网络请求确实比较稳妥，不太容易出现问题。但在实际开发中，可能会由于需求的不同而存在更多的请求节点选择。 同步网络请求同步的请求很少出现。这类请求最好在constructor和willMount阶段进行，因为同步请求会阻塞React组件的渲染及浏览器事件。在组件渲染完毕，会调用didMount方法。如果在这个时间发送同步请求，务必会阻塞用户和页面的交互，造成页面假死的现象。而在render之前，constructor和willMount均未渲染出页面，此时进行同步请求也只会使用户觉得组件或页面正在加载中。 异步网络请求异步网络请求是在开发中最常见的，它并不会阻塞组件的渲染。将这类请求放在constructor和willMount中效率会更高。异步请求在取得response后通常会使用setState来触发render。didMount调用时实际上已经render过一次，如果在didMount中请求数据，至少会经历两次render（假设请求成功）。setState实际上是将更新的状态放进了组件的__pendingStateQueue队列。速度足够快的情况下，在constructor和willMount中的请求能够在第一次render前进行setState，此时setState并不会触发渲染，而是会在组件进行第一次render的时候统一渲染，实际只进行了一次render。如果没有在第一次render前获取到response，最多也只会和didMount中请求一样的效果，进行两次渲染。综上，将异步请求放在constructor和willMount中会显得更加的高效。 在construcor中发出的异步请求（microTask）如果足够快，会在组件没有mounted前调用setState，这个时候是不成功的，必须直接使用this.state = {} 的形式设置state，这需要增加额外的判断。 不涉及UI渲染的网络请求我们一般不依赖这类请求的response，只需要强调请求的发送。所以比较适合在constructor阶段完成。 SSR（服务端渲染）如果网站考虑SSR的话，那么网络请求要尽可能的放到didMount中，因为didMount在SSR的过程中并不会被执行，且SSR生成HTML的过程中也不需要执行网络请求（没有意义）。 Fiber reconcilerFiber是React16所采用的协调算法，可以通过这篇文章深入了解。使用Fiber后，组件render前的生命周期方法可能会被打断，也就意味这这些方法可能会被多次执行。因此，在React16后，初始网络请求都要尽量在didMount中执行。 总结","link":"/2019/02/23/React和Vue网络请求的时间点分析/"}],"tags":[{"name":"作用域","slug":"作用域","link":"/tags/作用域/"},{"name":"webpack css","slug":"webpack-css","link":"/tags/webpack-css/"},{"name":"Grid Layout","slug":"Grid-Layout","link":"/tags/Grid-Layout/"},{"name":"生命周期","slug":"生命周期","link":"/tags/生命周期/"},{"name":"网络请求","slug":"网络请求","link":"/tags/网络请求/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"React","slug":"React","link":"/categories/React/"}]}